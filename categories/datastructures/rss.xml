<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Aurora - DataStructures</title>
        <link>https://oliverdding.github.io</link>
        <description>Sidere mens eadem mutato</description>
        <generator>Zola</generator>
        <language>zh</language>
        <atom:link href="https://oliverdding.github.io/categories/datastructures/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 09 Feb 2022 17:13:10 +0800</lastBuildDate>
        <item>
            <title>布隆过滤器</title>
            <pubDate>Wed, 09 Feb 2022 17:13:10 +0800</pubDate>
            <link>https://oliverdding.github.io/posts/bloom-filter/</link>
            <guid>https://oliverdding.github.io/posts/bloom-filter/</guid>
            <description>&lt;p&gt;布隆过滤器（Bloom Filter）是一种类似于哈希表的数据结构，但相比于后者空间利用率更高。&lt;&#x2F;p&gt;
&lt;p&gt;使用布隆过滤器查找key时，返回值可能情况有两种：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;key&lt;strong&gt;不&lt;&#x2F;strong&gt;存在&lt;&#x2F;li&gt;
&lt;li&gt;key&lt;strong&gt;可能&lt;&#x2F;strong&gt;存在&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;yuan-li&quot;&gt;原理&lt;&#x2F;h2&gt;
&lt;p&gt;布隆过滤器由以下三部分构成：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;n个key&lt;&#x2F;li&gt;
&lt;li&gt;m位的位图：&lt;code&gt;bitmap&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;k个无关的hash函数：&lt;code&gt;h1, h2, ..., hk&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;blockquote&gt;
&lt;p&gt;可以用$h_{i}(x)=MD5(x+i)$或者$h_{i}(x)=MD5(x|i)$实现k个无关hash函数&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;需要插入key时，对&lt;code&gt;key = a&lt;&#x2F;code&gt;时，经过k个hash函数后得到&lt;code&gt;h1(a), h2(a), ..., hk(a)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;此时将&lt;code&gt;bitmap&lt;&#x2F;code&gt;中对应的位置1。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8F%92%E5%85%A5%E6%96%B0key.drawio.svg&quot; alt=&quot;布隆过滤器插入新key示意图&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;当key越来越多，&lt;code&gt;bitmap&lt;&#x2F;code&gt;中为1的位越多，对于某个不存在的key，k个hash函数得到的坐标都为1的可能越大，此时就发生false positive。&lt;&#x2F;p&gt;
&lt;p&gt;那么k取何值时，false positive发生概率最小，此时概率为？&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shu-xue-zheng-ming&quot;&gt;数学证明&lt;&#x2F;h2&gt;
&lt;p&gt;对&lt;code&gt;bitmap&lt;&#x2F;code&gt;随机置位后，对于任意一个位，其被置0、1的概率分别是$P(0) = 1 - \frac{1}{m}$、$P(1) = \frac{1}{m}$&lt;&#x2F;p&gt;
&lt;p&gt;对于k个hash函数的置位后，对于任意一个位，仍然是0的概率是$$P’(0)=P(0)^{k}=(1 - \frac{1}{m})^{k}$$&lt;&#x2F;p&gt;
&lt;p&gt;对于n个key插入后，对于任意一个位，仍然是0的概率是$$P’‘(0)=P’(0)^{n}=(1 - \frac{1}{m})^{kn}$$&lt;&#x2F;p&gt;
&lt;p&gt;由于有自然对数e的计算公式$$\lim_{n \to \infty}{(1-\frac{1}{x})^{-x}}=e$$&lt;&#x2F;p&gt;
&lt;p&gt;我们可以近似计算$P’‘(0)$得到$$P’’(0)=(1-\frac{1}{m})^{kn}\approx{}e^{-\frac{kn}{m}}$$&lt;&#x2F;p&gt;
&lt;p&gt;因此，对于任意一个位，其被置1的概率是$$P’‘(1)=1-P’’(0)\approx{}1-e^{-\frac{kn}{m}}$$&lt;&#x2F;p&gt;
&lt;p&gt;当alse positive发生时，是指它的k个hash函数得到的坐标都为1。由于k个hash函数相互独立，我们可以计算出alse positive的概率为$$f=(1-(1-\frac{1}{m})^{kn})^{k}\approx{}(1-e^{-\frac{kn}{m}})^{k}$$&lt;&#x2F;p&gt;
&lt;p&gt;由于m、n是用户给定的值，唯一变量就是k，我们需要指定k的值去最小化alse positive概率。&lt;&#x2F;p&gt;
&lt;p&gt;另$p=e^{-\frac{kn}{m}}$，我们有$$f=(1-p)^{k}=e^{kln(1-p)}$$&lt;&#x2F;p&gt;
&lt;p&gt;此时变更为最小的$g=kln(1-p)$&lt;&#x2F;p&gt;
&lt;p&gt;无中生有下得到$$g=kln{}(1-p)=-\frac{m}{n}ln(e^{-\frac{kn}{m}})ln(1-p)=-\frac{m}{n}ln(p)ln(1-p)$$&lt;&#x2F;p&gt;
&lt;p&gt;得知当$p=\frac{1}{2}$时g取得最小，此时有$$k=ln(2\frac{m}{n})$$&lt;&#x2F;p&gt;
&lt;p&gt;插入回$$f=(1-p)^{k}$$得到alse positive的最小值为$$f_{min}=(\frac{1}{2})^{k}\approx{}(0.6185)^{\frac{m}{n}}$$&lt;&#x2F;p&gt;
</description>
        </item>
    </channel>
</rss>
