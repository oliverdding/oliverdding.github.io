<!doctype html><html lang=zh><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#ffffff name=theme-color><meta content=#da532c name=msapplication-TileColor><link href=/icons/site.webmanifest rel=manifest><link color=#5bbad5 href=/icons/safari-pinned-tab.svg rel=mask-icon><link href=/icons/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/icons/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/icons/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/galleria@1.6.1/dist/themes/folio/galleria.folio.min.css integrity=sha384-+rY0QD+LRnTOquDMzGa9lXU6jIwdiQuwCJQ2cdcW0qeP/0UbjQCZlXnRsUMA+9pH rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.9.1/css/academicons.min.css integrity=sha384-FIue+PI4SsI9XfHCz8dBLg33b0c1fMJgNU3X//L26FYbGnlSEfWmNT7zgWc2N9b6 rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css integrity=sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css integrity=sha384-IJLmUY0f1ePPX6uSCJ9Bxik64/meJmjSYD7dHaJqTXXEBE4y+Oe9P2KBZa/z7p0Q rel=stylesheet><link href=https://charmer.fun/deep-thought.css rel=stylesheet><title> Aurora | 通过例子快速入门C++ </title><script src="https://www.googletagmanager.com/gtag/js?id=G-LXDSXGWDES" async></script><script>window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());
    gtag("config", "G-LXDSXGWDES");</script><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-jiBVvJ8NGGj5n7kJaiWwWp9AjC+Yh8rhZY3GtAX8yU28azcLgoRo4oukO87g7zDT src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mathtex-script-type.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js></script><body class=has-background-white><nav aria-label="section navigation" class="navbar is-light" role=navigation><div class=container><div class=navbar-brand><a class="navbar-item is-size-5 has-text-weight-bold" href=https://charmer.fun>Aurora</a><a class="navbar-burger burger" aria-expanded=false aria-label=menu data-target=navMenu role=button> <span aria-hidden=true></span> <span aria-hidden=true></span> <span aria-hidden=true></span> </a></div><div class=navbar-menu id=navMenu><div class="navbar-end has-text-centered"><a class="navbar-item has-text-weight-semibold" href=https://charmer.fun/> Home </a><a class="navbar-item has-text-weight-semibold" href=https://charmer.fun/posts> Posts </a><a class="navbar-item has-text-weight-semibold" href=https://charmer.fun/categories> Categories </a><a class="navbar-item has-text-weight-semibold" href=https://charmer.fun/tags> Tags </a><a class=navbar-item data-target=#search-modal id=nav-search title=Search> <span class=icon> <i class="fas fa-search"></i> </span> </a><a title="Switch to dark theme" class=navbar-item id=dark-mode> <span class=icon> <i class="fas fa-adjust"></i> </span> </a></div></div></div></nav><section class=section><div class=container><div class=columns><div class="column is-8 is-offset-2"><article class=box><h1 class=title>通过例子快速入门C++</h1><p class=subtitle>原文链接: http://www.tfd.chalmers.se/~hani/kurser/OS_CFD_2007/c++.pdf<div class="columns is-multiline is-gapless"><div class="column is-8"><span class="icon-text has-text-grey"> <span class=icon> <i class="fas fa-user"></i> </span> <span>charmer published on</span> <span class=icon> <i class="far fa-calendar-alt"></i> </span> <span><time datetime=2022-03-07T14:37:06+08:00>March 07, 2022</time></span> </span></div><div class="column is-4 has-text-right-desktop"><span class="icon-text has-text-grey"> <span class=icon> <i class="far fa-clock"></i> </span> <span>7 min,</span> <span class=icon> <i class="fas fa-pencil-alt"></i> </span> <span>1394 words</span> </span></div><div class=column><p>Categories: <a class="has-text-info-dark has-text-weight-semibold" href=https://charmer.fun/categories/c-plus-plus/> <span class=icon-text> <span class=icon> <i class="fas fa-cube"></i> </span> <span>C Plus Plus</span> </span> </a></div><div class="column has-text-right-desktop"><p>Tags: <a class="has-text-info-dark has-text-weight-semibold" href=https://charmer.fun/tags/c-plus-plus/> <span class=icon-text> <span class=icon> <i class="fas fa-tag"></i> </span> <span>c plus plus</span> </span> </a> <a class="has-text-info-dark has-text-weight-semibold" href=https://charmer.fun/tags/programming-language/> <span class=icon-text> <span class=icon> <i class="fas fa-tag"></i> </span> <span>programming language</span> </span> </a></div></div><div class="content mt-2"><p>⚠️ 本文为阅读笔记，<a rel="noopener nofollow noreferrer" href=http://www.tfd.chalmers.se/%7Ehani/kurser/OS_CFD_2007/c++.pdf target=_blank>原文</a>为Tom Anderson对C++的<strong>子集</strong>的介绍。<p>在学习前需要解释的一点是，C++的内容可以划分为：<ol><li>基础部分，包含类、成员函数、构造器等等<li>进阶部分，包含单例继承、模版等等<li>垃圾部分，包含多重继承、异常、超载、引用等等</ol><p>1是本文重点，每个C++程序员都应该掌握；2则是看到再查，但避免在自己的程序中使用；3则永远不要碰。<hr><h2 id=c-bao-han-c>C++包含C</h2><p>很大程度上，C++是C的超集，大部分符合ANSI的C程序都可以被C++编译器编译。不过有以下几个地方需要注意：<ol><li><p>所有函数都要先声明后使用。（在C中使用未声明的函数默认返回值是int）</p><li><p>所有函数的声明和定义头必须使用new-style声明，如</p> <pre class=language-c++ data-lang=c++ style=background-color:#282828;color:#fdf4c1aa;><code class=language-c++ data-lang=c++><span style=color:#fa5c4b;>extern int </span><span style=color:#8ec07c;>foo</span><span>(</span><span style=color:#fa5c4b;>int </span><span style=color:#fdf4c1;>a</span><span>, </span><span style=color:#fa5c4b;>char</span><span style=color:#fe8019;>* </span><span style=color:#fdf4c1;>b</span><span>);
</span></code></pre> <p>（在C中可以<code>extern int foo();</code>表示函数foo未知的参数数量和类型）</p><li><p>需要链接C的对象文件时，需要这样声明C函数：</p> <pre class=language-c++ data-lang=c++ style=background-color:#282828;color:#fdf4c1aa;><code class=language-c++ data-lang=c++><span style=color:#fa5c4b;>extern </span><span style=color:#b8bb26;>"C" </span><span style=color:#fa5c4b;>int </span><span style=color:#8ec07c;>foo</span><span>(</span><span style=color:#fa5c4b;>int </span><span style=color:#fdf4c1;>a</span><span>, </span><span style=color:#fa5c4b;>char</span><span style=color:#fe8019;>* </span><span style=color:#fdf4c1;>b</span><span>);
</span></code></pre><li><p>C++包含需要新关键词，不能被用作标识符（identifiers）。它们是：<code>new</code>，<code>delete</code>，<code>const</code>和<code>class</code></p></ol><h2 id=ji-chu-bu-fen>基础部分</h2><p>在开始讲解之前，下面三组面对对象语言的通用概念必须了解：<ul><li><strong>class</strong> and <strong>object</strong><li><strong>member functions</strong> <ul><li><strong>constructor</strong><li><strong>destructor</strong></ul><li><strong>private</strong> vs. <strong>public</strong></ul><p>接下来用例子描述C++中的各类基础特性。<h3 id=lei>类</h3><p>为了直观展示C++中的类使用，将以栈类的代码实现为例子。<p>在C++中，类的定义和实现是分离的（有种特殊情况，后文提到）。通常，在<code>.h</code>头文件中存放类的定义，在<code>.cc</code>文件中存放类的成员函数实现。<pre class=language-c++ data-lang=c++ style=background-color:#282828;color:#fdf4c1aa;><code class=language-c++ data-lang=c++><span style=font-style:italic;color:#928374;>// stack.h
</span><span style=color:#fa5c4b;>class </span><span style=color:#8ec07c;>Stack </span><span>{
</span><span>        </span><span style=color:#fa5c4b;>int</span><span style=color:#fe8019;>*</span><span> stack;            </span><span style=font-style:italic;color:#928374;>// 1.1
</span><span>    </span><span style=color:#fa5c4b;>public</span><span>:                    </span><span style=font-style:italic;color:#928374;>// 1.2
</span><span>        </span><span style=color:#8ec07c;>Stack</span><span>(</span><span style=color:#fa5c4b;>int </span><span style=color:#fdf4c1;>sz</span><span>);         </span><span style=font-style:italic;color:#928374;>// 1.3
</span><span>        </span><span style=color:#8ec07c;>~Stack</span><span>();              </span><span style=font-style:italic;color:#928374;>// 1.4
</span><span>        </span><span style=color:#fa5c4b;>void </span><span style=color:#8ec07c;>Push</span><span>(</span><span style=color:#fa5c4b;>int </span><span style=color:#fdf4c1;>value</span><span>);  </span><span style=font-style:italic;color:#928374;>// 1.5
</span><span>        </span><span style=color:#fa5c4b;>bool </span><span style=color:#8ec07c;>Full</span><span>() </span><span style=color:#fa5c4b;>const </span><span>{ </span><span style=color:#fa5c4b;>return </span><span>(top </span><span style=color:#fe8019;>==</span><span> size); };     </span><span style=font-style:italic;color:#928374;>// 1.6
</span><span>    </span><span style=color:#fa5c4b;>private</span><span>:                   </span><span style=font-style:italic;color:#928374;>// 7
</span><span>    </span><span style=color:#fa5c4b;>private</span><span>:                   </span><span style=font-style:italic;color:#928374;>// 7
</span><span>        </span><span style=color:#fa5c4b;>int</span><span> top;
</span><span>        </span><span style=color:#fa5c4b;>int</span><span> size;
</span><span>}
</span></code></pre><h4 id=cheng-yuan-han-shu>成员函数</h4><p>在stack.h头文件中<em>1.1</em>就是<code>Stack</code>类的普通成员函数。我们给出它的实现：<pre class=language-c++ data-lang=c++ style=background-color:#282828;color:#fdf4c1aa;><code class=language-c++ data-lang=c++><span style=font-style:italic;color:#928374;>// stack.cc
</span><span style=color:#fa5c4b;>void
</span><span>Stack::</span><span style=color:#8ec07c;>Push</span><span>(</span><span style=color:#fa5c4b;>int </span><span style=color:#fdf4c1;>value</span><span>) {         </span><span style=font-style:italic;color:#928374;>// 2.1
</span><span>    </span><span style=color:#fdf4c1;>ASSERT(</span><span style=color:#fe8019;>!</span><span style=color:#fdf4c1;>this->Full())</span><span>;       </span><span style=font-style:italic;color:#928374;>// 2.2
</span><span>    stack[</span><span style=color:#fdf4c1;>this</span><span>-></span><span style=color:#fdf4c1;>top</span><span style=color:#fe8019;>++</span><span>] </span><span style=color:#fe8019;>=</span><span> value;  </span><span style=font-style:italic;color:#928374;>// 2.3
</span><span>}
</span></code></pre><p>首先看到<em>2.1</em>，<em>class::function</em>的标识符表明<code>Push</code>是类的成员函数。<p>在<em>2.2</em>中，成员函数体内可以直接使用对象的成员，这里访问了<code>Full()</code>函数。C++可以通过<code>-></code>操作符访问对象的成员，同时，在成员函数内可以通过<code>this</code>变量指代当前对象，通常<code>this</code>是隐式的，因此可以改写成<code>ASSERT(!Full());</code>，<em>2.3</em>即是隐式调用对象成员。<h4 id=si-you-cheng-yuan>私有成员</h4><p>面对对象编程自然必须涉及封装。C++提供了私有成员的方式实现封装。默认情况下C++类成员为私有成员，如<em>1.1</em>就是私有的，成员函数内可以随意使用，但外部不可见。<p>可以显示使用<code>public</code>关键词表明后续成员为公有成员，如<em>1.2</em>所示。<p>对之对应，可以使用<code>private</code>关键词表明后续成员为私有成员。<p>❤️ 所有包含数据的成员变量都应当私有。<h4 id=gou-zao-han-shu-he-newcao-zuo-fu>构造函数和new操作符</h4><pre class=language-c++ data-lang=c++ style=background-color:#282828;color:#fdf4c1aa;><code class=language-c++ data-lang=c++><span style=font-style:italic;color:#928374;>// stack.cc
</span><span>Stack::</span><span style=color:#8ec07c;>Stack</span><span>(</span><span style=color:#fa5c4b;>int </span><span style=color:#fdf4c1;>sz</span><span>) {
</span><span>    size </span><span style=color:#fe8019;>=</span><span> sz;
</span><span>    top </span><span style=color:#fe8019;>= </span><span style=color:#d3869b;>0</span><span>;
</span><span>    stack </span><span style=color:#fe8019;>= </span><span style=color:#fa5c4b;>new int</span><span>[size];  </span><span style=font-style:italic;color:#928374;>// 3.1
</span><span>}
</span></code></pre><p><em>1.3</em>即是Stack类的构造函数，构造函数用于给对象成员赋予默认值，并进行一些初始化操作。在C++中，使用<code>new</code>关键词进行对象创建，它会自动调用类的构造函数。这个流程同样适用于自动变量。<p>对于类来说构造函数是必须的，若没有显示定义，编译器会给你加上一个空构造函数。<p>有两种方式传递函数参数给构造函数：<pre class=language-c++ data-lang=c++ style=background-color:#282828;color:#fdf4c1aa;><code class=language-c++ data-lang=c++><span style=color:#fa5c4b;>void
</span><span style=color:#8ec07c;>test</span><span>() {
</span><span>    </span><span style=font-style:italic;color:#928374;>// 通过new关键词（堆上变量）
</span><span>    Stack</span><span style=color:#fe8019;>*</span><span> s1 </span><span style=color:#fe8019;>= </span><span style=color:#fa5c4b;>new </span><span style=color:#fdf4c1;>Stack(</span><span style=color:#d3869b;>128</span><span style=color:#fdf4c1;>)</span><span>;  </span><span style=font-style:italic;color:#928374;>// 4.1
</span><span>
</span><span>    </span><span style=font-style:italic;color:#928374;>// 自动变量或全局变量（栈上变量）
</span><span>    Stack </span><span style=color:#fdf4c1;>s2(</span><span style=color:#d3869b;>128</span><span style=color:#fdf4c1;>)</span><span>;               </span><span style=font-style:italic;color:#928374;>// 4.2
</span><span>}
</span></code></pre><p>函数内的变量在函数返回时会自动释放，比如<em>4.2</em>定义的s2就会在test()函数返回时释放。但是通过new关键词创建的变量（如<em>4.1</em>)存储在堆（heap）上，即是函数返回仍然存在，必须手动delete。<p>new关键词也可以用来分配数组，如<em>3.1</em>所示。同样需要手动delete。<h4 id=xi-gou-han-shu-he-deletecao-zuo-fu>析构函数和delete操作符</h4><pre class=language-c++ data-lang=c++ style=background-color:#282828;color:#fdf4c1aa;><code class=language-c++ data-lang=c++><span>Stack::</span><span style=color:#8ec07c;>~Stack</span><span>() {
</span><span>    </span><span style=color:#fa5c4b;>delete []</span><span> stack;  </span><span style=font-style:italic;color:#928374;>// 5.1
</span><span>}
</span></code></pre><p>有构造函数就有析构函数，就如有new就有delete。<p>对于new出来的对象，使用delete手动释放，如<em>4.1</em>的s1：<code>delete d1;</code>。<p>对于new出来的数组，也使用delete手动释放，如<em>5.1</em>所示。注意中间的<code>[]</code>表明释放数组，而不是数组中单个变量。<h3 id=qi-ta-c-de-ji-chu-te-xing>其他C++的基础特性</h3><ol><li>类可以作为数据类型使用。<li>事实上可以在类是声明时（头文件）内同时声明实现函数，如<em>1.6</em>所示。但通常要求函数体简单。这么做有两个好处：方便和性能。在类声明时实现的函数会被当作<code>inline</code>函数。<li>const关键词除了像C一样声明变量时使用，表示变量不可变，还可以用于函数声明，表明函数对数据只读而不会修改，如<em>1.6</em>。<li><code>cin</code>和<code>cout</code>对象是C++中的标准输入输出。使用<code>>></code>和<code><<</code>分别输入、输出。</ol><h2 id=jin-jie-bu-fen>进阶部分</h2><p>这部分内容容易误用，但如果用得恰当可以大幅简化逻辑。<p>后面内容由于博主没有使用场景，暂时不学习。😛<h3 id=dan-li-ji-cheng>（单例）继承</h3><h3 id=mo-ban>模版</h3><h2 id=la-ji-bu-fen>垃圾部分</h2></div></article></div><div class="column is-2 is-hidden-mobile"><aside style="position: sticky; top: 48px" class=menu><p class="heading has-text-weight-bold">Contents<ul class=menu-list><li><a class="toc is-size-7 is-active" href=https://charmer.fun/posts/a-quick-introduction-to-c-plus-plus/#c-bao-han-c id=link-c-bao-han-c> C++包含C </a><li><a class="toc is-size-7" href=https://charmer.fun/posts/a-quick-introduction-to-c-plus-plus/#ji-chu-bu-fen id=link-ji-chu-bu-fen> 基础部分 </a> <ul><li><a class="toc is-size-7" href=https://charmer.fun/posts/a-quick-introduction-to-c-plus-plus/#lei id=link-lei> 类 </a><li><a class="toc is-size-7" href=https://charmer.fun/posts/a-quick-introduction-to-c-plus-plus/#qi-ta-c-de-ji-chu-te-xing id=link-qi-ta-c-de-ji-chu-te-xing> 其他C++的基础特性 </a></ul><li><a class="toc is-size-7" href=https://charmer.fun/posts/a-quick-introduction-to-c-plus-plus/#jin-jie-bu-fen id=link-jin-jie-bu-fen> 进阶部分 </a> <ul><li><a class="toc is-size-7" href=https://charmer.fun/posts/a-quick-introduction-to-c-plus-plus/#dan-li-ji-cheng id=link-dan-li-ji-cheng> （单例）继承 </a><li><a class="toc is-size-7" href=https://charmer.fun/posts/a-quick-introduction-to-c-plus-plus/#mo-ban id=link-mo-ban> 模版 </a></ul><li><a class="toc is-size-7" href=https://charmer.fun/posts/a-quick-introduction-to-c-plus-plus/#la-ji-bu-fen id=link-la-ji-bu-fen> 垃圾部分 </a></ul></aside></div></div></div></section><section class=modal id=search-modal><div class=modal-background></div><div class=modal-card><header class=modal-card-head><p class=modal-card-title>Search</header><section class=modal-card-body><div class="field mb-2"><div class=control><input placeholder="Search this website." class=input id=search type=search></div></div><div class=search-results><div class=search-results__items></div></div></section></div><button class="modal-close is-large" aria-label=close></button></section><section class=section><div class=container><div class="columns is-centered"><div class="column is-8"><nav class=level><div class="level-item has-text-centered"><a class="button is-black is-outlined" href=https://charmer.fun/posts/rust-traits-and-trait-objects/> <span class="icon mr-2"> <i class="fas fa-arrow-circle-left"></i> </span> trait对象的静态分发与动态分发 </a></div><div class="level-item has-text-centered"><a class="button is-black is-outlined" href=https://charmer.fun/posts/hyper-log-log/> HyperLogLog<span class="icon ml-2"> <i class="fas fa-arrow-circle-right"></i> </span> </a></div></nav></div></div></div></section><section class=section><div class=container><div class="columns is-centered"><div class="column is-6"><div id=disqus_thread></div></div></div></div></section><footer class="footer py-4"><div class="content has-text-centered"><p>Built with <span class=icon-text> <span class=icon> <i class="fas fa-code"></i> </span> <span>code</span> </span> and <span class=icon-text> <span class=icon> <i class="fas fa-heart"></i> </span> <span>love</span> </span><p>Powered by <span class=icon-text> <span class=icon> <i class="fas fa-power-off"></i> </span> <span>zola</span> </span></div></footer><script crossorigin=anonymous integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK src=https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js></script><script crossorigin=anonymous integrity=sha384-QSfwGT8/EU536DKdtyP2D6SLlh8zBaZ0cVkwfrwhqzIU9VCfJT00CLVP5t+HAiYg src=https://cdn.jsdelivr.net/npm/galleria@1.6.1/dist/galleria.min.js></script><script crossorigin=anonymous integrity=sha384-DwpKI+deZB267+hPKwiOIc5Y2GKsVL0mR6hgz7GgIu7AgAMYqJwcJKY1YBNfhWcY src=https://cdn.jsdelivr.net/npm/galleria@1.6.1/dist/themes/folio/galleria.folio.min.js></script><script crossorigin=anonymous integrity=sha384-0yWn54pSGtfKCU+skfA69l25VsCw+MZt4LQov3xNRoS7YkAMrFokGgSBnAWSK4pv src=https://cdn.jsdelivr.net/npm/mermaid@8.13.5/dist/mermaid.min.js></script><script crossorigin=anonymous integrity=sha384-xC3h1+IHXK8seA+8KfT79Z4e0GPsznjXBoMa5nd8ooWKplPyXx92NOmljWxLC/cs src=https://cdn.jsdelivr.net/npm/chart.xkcd@1.1.13/dist/chart.xkcd.min.js></script><script src=https://charmer.fun/elasticlunr.min.js></script><script src=https://charmer.fun/search_index.zh.js></script><script src=https://charmer.fun/js/site.js></script><script>const menuBarHeight = document.querySelector("nav.navbar").clientHeight;
  const tocItems = document.querySelectorAll(".toc");
  const navSections = new Array(tocItems.length);

  tocItems.forEach((el, i) => {
    let id = el.getAttribute("id").substring(5);
    navSections[i] = document.getElementById(id);
  })

  function isVisible(tocIndex) {
    const current = navSections[tocIndex];
    const next = tocIndex < tocItems.length - 1 ? navSections[tocIndex + 1]
      : document.querySelectorAll("section.section").item(1);

    const c = current.getBoundingClientRect();
    const n = next.getBoundingClientRect();
    const h = (window.innerHeight || document.documentElement.clientHeight);

    return (c.top <= h) && (n.top - menuBarHeight >= 0);
  }

  function activateIfVisible() {
    for (b = true, i = 0; i < tocItems.length; i++) {
      if (b && isVisible(i)) {
        tocItems[i].classList.add('is-active');
        b = false;
      } else
        tocItems[i].classList.remove('is-active');
    }
  }

  var isTicking = null;
  window.addEventListener('scroll', () => {
    if (!isTicking) {
      window.requestAnimationFrame(() => {
        activateIfVisible();
        isTicking = false;
      });
      isTicking = true;
    }
  }, false);</script><script>var disqus_config = function () {
    this.page.url = "https://charmer.fun";
    this.page.identifier = "/posts/a-quick-introduction-to-c-plus-plus/";
  };

  (function () {
    var d = document, s = d.createElement('script');
    s.src = 'https://oliverdding.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();</script>